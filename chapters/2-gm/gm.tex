\chapter{Graph Matching}
\chaptermark{Graph Matching}
\label{chap:gm}
\graphicspath{{./chapters/2-gm/figs/}}
% Abstract---------------------------------------------------------
Graph is a powerful tool for any visual object representation. In this chapter, we will discuss some of the key definitions regarding graphs. Graph comparison is a crucial operation and it is needed for the sake of comparison of two objects represented with graphs. This process can roughly be defined as \emph{graph matching}. In pattern recognition, the methods of graph matching are broadly divided into two categories viz. \emph{exact} and \emph{inexact}. In this chapter we will discuss the concepts of exact and inexact graph matching techniques. Also some of the key graph comparison approaches such as graph edit distance, graph indexing, graph kernel and some related concepts will be reviewed. As this thesis methodologically focuses on subgraph matching, at the end of this chapter we will give a brief overviews and state-of-the-art reviews on the other subgraph matching algorithms. Some of the definitions, concepts in this chapter are written inspired from the PhD thesis of Dr. Jaume Gibert~\cite{GibertThesis2012}.

\section{Graphs and Subgraphs}
\begin{definition}[Graph]
Let $L_V$ and $L_E$ be any two sets of labels. An \emph{attributed graph} is a 4-tuple $G=(V\mcomma E\mcomma\alpha\mcomma\beta)$, where $V$ is a finite set of nodes or vertices, $E\subseteq V\times V$ is the set edges, $\alpha:V\rightarrow L_V$ is the node labelling function assigning a label from the set $L_V$ to each of the nodes in $V$ and $\beta:E\rightarrow L_E$ is the edge labelling function assigning a label from the set $L_E$ to each of the edges in $E$.
\end{definition}

The number of nodes of a graph $G$ is denoted by $|V|$. Edges of a graph are usually identified by the pair of nodes they link. An edge $e\in E$ can thus be represented as $e=(u,v)$, where $u,v\in V$ are the nodes joined by the edge $e$. The number of edges in a graph $G$ is denoted by $|E|$. Based on the definitions of the labelling sets $L_V$, $L_E$ and the labelling functions $\alpha$, $\beta$, there also exist different types of graphs. For instance, the graphs whose labelling sets are sets of discrete values is called \emph{discretely attributed graphs}. On the other hand the graphs whose labelling sets are any subset of $\mathbb{R}^{d}$ for $d>1$, are called \emph{continuously attributed graphs}. Moreover, $L_V$ and/or $L_E$ can be empty sets, in that case the graphs are named as \emph{unattributed graphs}.

\begin{definition}[Directed Graph]
A \emph{directed graph} is a graph where all the edges have a specific direction. For example, by the edge $e=(u,v)$, we mean the edge $e$ is originated at the node $u$ and terminated at the node $v$. The existence of an edge $e=(u,v)$ does not assure the existence of the edge $e^\prime=(v,u)$.
\end{definition}

\begin{definition}[Undirected Graph]
An \emph{undirected graph} is a graph where for any edge $e=(u,v)$, there always exist an edge $e^\prime=(v,u)$ such that $\beta(e)=\beta(e^\prime)$.
\end{definition}

\begin{definition}[Subgraph]
Let $G_1=(V_1,E_1,\alpha_1,\beta_1)$ and $G_2=(V_2,E_2,\alpha_2,\beta_2)$ be two graphs. Then the graph $G_1$ is said to be a \emph{subgraph} of $G_2$ and is denoted by $G_1\subseteq G_2$ if the following conditions hold.
\end{definition}

\begin{itemize}
\item $V_1\subseteq V_2$
\item $E_1=E_2\cap V_1\times V_2$
\item $\alpha_1(u)=\alpha_2(u),\forall u\in V_1$
\item $\beta_1(e)=\beta_2(e),\forall e\in E_1$
\end{itemize}

From this definition, a subgraph of a graph can be obtained by removing some nodes and all their incident edges. In this case the subgraph is called \emph{induced}. If, however, the second condition of the definition is substituted by $E_1\subseteq E_2$, not only the incident edges to the deleted nodes are removed but also some other edges have to be removed. In this case the subgraph is called \emph{non-induced}.

\section{Graph matching}
Given two attributed graphs, \emph{graph matching} can roughly be defined as a process for finding correspondence between the node and edge sets of two graphs that satisfies some constraints. In pattern recognition, the research community has divided the graph matching methods into two broad categories: (1) exact and (2) inexact graph matching. The \emph{exact matching} requires a strict correspondence among the two objects being matched or at least among their sub parts. On the other hand the \emph{inexact graph matching} methods allow some tolerance for matching and in this case a matching can occur where two graphs being matched can be structurally different to some extent. This kind of graph matching also called as \emph{error tolerant subgraph matching}.

As in all subfields of mathematics, also in graph theory the relation between two objects or entities can be established in terms of a mapping. Depending on the nature of mapping graph matching can also be of different types: \emph{graph isomorphism}, \emph{graph monomorphism} and \emph{graph homomorphism}, where graph isomorphism can be defined as follows:
\begin{definition}[Graph Isomorphism]
Let $G_1=(V_1\mcomma E_1\mcomma\alpha_1\mcomma\beta_1)$ and $G_2=(V_2\mcomma E_2\mcomma\alpha_2\mcomma\beta_2)$ be two graphs. $G_1$ is said to be isomorphic to $G_2$, denoted by $G_1\cong G_2$, if there exist a bijection $f:V_1\rightarrow V_2$ such that for any $u,v\in V_1$ and $(u,v)\in E_1$ if and only if $\exists f(u),f(v)\in V_2$ and $(f(u),f(v))\in E_2$. In this case the two graphs $G_1$ and $G_2$ are called \emph{isomorphic}.
\end{definition}
Similarly the graph homomorphism and monomorphism can also be defined depending on the type of functions $f$. 

A particular class of graph matching algorithms resulting from the consideration of outliers is called \emph{subgraph matching}. It can roughly be defined as recognizing one graph as part of the other. Like graph matching, subgraph matching also includes altogether subgraph homomorphism, isomorphism and monomorphism. Subgraph isomorphism can be formally defined as follows:
\begin{definition}[Subgraph Isomorphism]
Let $G_1=(V_1,E_1,\alpha_1,\beta_1)$ and $G_2=(V_2\mcomma E_2\mcomma\alpha_2\mcomma\beta_2)$ be two graphs. $G_1$ is said to be isomorphic to a subgraph $S_2$ of $G_2$, denoted by $G_1\cong S_2\subseteq G_2$, if there exist an injection $\phi:V_1\rightarrow V_2$ such that for any $u,v\in V_1$, $(u,v)\in E_1$ if and only if $\exists\phi(u),\phi(v)\in V_2$ and $(\phi(u),\phi(v))\in V_2$.
\end{definition}
Subgraph homomorphism and monomorphism can also be defined depending on the function $\phi$. Exact graph or subgraph isomorphism are classified as computationally hard problem \cite{Mehlhorn1984}. So the graph theory community tries to solve this problem in some inexact and approximated way. Later in this chapter we provide a detailed review and references of (sub)graph matching algorithms.

\section{Graph edit distance}
\label{sec:gm:ged}
Graph edit distance comes from the necessity of having a dissimilarity measure between two graphs. In pattern recognition when two objects are represented with graphs, it is often needed to have a distance or similarity measure between them. This is a very difficult task as graph can be multidimensional. The basic idea behind \emph{graph edit distance} is to define a dissimilarity measure between two graphs by the minimum amount of edition needed to transform one graph to another~\cite{Tsai1979}. To this end, a number of edit operations $e$, consisting of the \emph{insertion}, \emph{deletion} and \emph{substitution} of pair of nodes and edges together with \emph{merging} of a series of nodes and edges must be defined. Then for a pair of graphs $G_1$ and $G_2$, there exist a sequence of edit operations or edit path $p(G_1,G_2)=(e_1,\dots,e_k)$, (where each $e_i$ denotes an edit operation) that transforms $G_1$ to $G_2$ or vice versa. The total distance measure of editing a graph to another can be obtained by attaching an edit cost to each of the edit operations and summing them up. In general, there might exist more than one edit path that transform the graph $G_1$ to $G_2$, let $\mathbb{P}(G_1,G_2)$ be the set of all such paths. One example of such paths $p(G_1,G_2)\in\mathbb{P}(G_1,G_2)$ is shown in~\fig{fig:gm:ged}. The edit distance between two graphs $G_1$ and $G_2$ is defined as the minimum total edit cost of all such paths that transform $G_1$ to $G_2$. It is formally defined as follows:

\begin{definition}[Graph edit distance]
Given two graphs $G_1=(V_1,E_1,\alpha_1,\beta_1)$ and $G_2=(V_2,E_2,\alpha_2,\beta_2)$, the graph edit distance between $G_1$ and $G_2$ is defined by:

\[
d(G_1,G_2)=\min_{(e_1,\dots,e_k)\in\mathbb{P}(G_1,G_2)}\sum_{i=1}^{k}c(e_i)
\]

where $c(e)$ denotes the cost of an edit operation $e$.
\end{definition}

\begin{figure}
\includegraphics[scale=0.37]{ged}
\caption{An edit path between two graphs. Node labels are represented by different colours.}
\label{fig:gm:ged}
\end{figure}

There are many kind of algorithms to compute graph edit distance. Optimal algorithms are based on combinatorial search procedures that explores all the possible mappings of nodes and edges of one graph to the nodes and edges of the second graph~\cite{Bunke1983}. The major drawback of such approach is the time complexity which is exponential to the size of the graphs. Then a number of suboptimal methods have been proposed to make the graph edit distance less computationally demanding~\cite{Neuhaus2004}. A linear programming method to compute the graph edit distance with unlabelled edges is proposed in~\cite{Justice2006}. An efficient suboptimal algorithm for graph edit distance computation is proposed based on bipartite optimization procedure in~\cite{Riesen2007a}. There are also some effort going on towards quadratic time approximation of graph edit distance~\cite{Fischer2013}.

\section{Graph indexing}
\label{sec:gm:gi}
In the core of many graph related applications, lies a common and critical problem: how to efficiently process graph queries and retrieve related graphs. In some cases, the success of an application directly relies on the efficiency of the query processing system. The classical graph query problem can be defined as: given a graph database $D=\lbrace g_1,g_2,\ldots,g_n\rbrace$ and a graph query $q$, find all the graphs in $D$, in which $q$ is a subgraph. It is inefficient to perform a sequential search on $D$ and check whether $q$ is a subgraph of any graph $g_i\in D$. Sequential search in such a manner is inefficient because in this way one not only has to access the whole graph database but also has to check subgraph isomorphism which is an NP-complete problem. Since generally the size of $D$ is huge, sequential searching in this manner is nearly impossible. This creates the necessity to build graph indices in order to help the processing of graph queries. XML query is a simple kind of graph query, which is usually built around path expressions. There are various indexing methods available~\cite{Sossa1992,Giugno2002,Kaushik2002,Yan2004,Shokoufandeh2005,Zhang2007a}. The methods can be categorized in terms of the basic indexing unit such as \emph{graph paths}~\cite{Giugno2002}, \emph{frequent graph structure}~\cite{Yan2004}, \emph{subtree}~\cite{Shokoufandeh2005} and they are developed depending on the type of applications.

\section{Graph embedding}
\label{sec:gm:ge}
The necessity of graph embedding comes from some of the major drawbacks of graph based methods, that is the significantly increased complexity of many algorithms. For example, the comparison between two vectors for identity can be done in linear time complexity with respect to the length of the vectors. On the other hand, for testing two graphs for isomorphism only the exponential algorithms are known today. Apart from that some of the basic operations like weighted summation or multiplication etc. of pair of entities in graph domain are not defined but these are elementary operations in many classification and clustering algorithms. \emph{Graph embedding} can roughly be defined as the procedure of mapping graphs either explicitly or implicitly into high dimensional spaces for the sake of performing basic mathematical operation required by various statistical pattern recognition techniques. The graph embedding methods are formally categorized as \emph{explicit graph embedding} and \emph{implicit graph embedding}.

\subsection{Explicit graph embedding}
\label{ssec:gm:ege}
\begin{definition}\emph{Explicit graph embedding} can be defined as the procedure of mapping graphs from arbitrary graph domains $\mathcal{G}$ to a real vector space $\mathbb{R}^n$ by means of functions such as $\varphi:\mathcal{G}\rightarrow \mathbb{R}^n$.
\end{definition}

The main aim of this kind of graph embedding is to provide an $n$-dimensional vector for each graph $G\in\mathcal{G}$ such that the distance between the embedded vectors $x_i$ and $x_j$ respectively of the graphs $G_i$ and $G_j$ is as close as possible to the distance between $G_i$ and $G_j$. There are many explicit graph embedding algorithms based on different paradigms such as spectral properties~\cite{Luo2003}, dissimilarity measures to selected prototypes~\cite{Bunke2010}, node attribute statistics~\cite{Gibert2012}, fuzzy assignment~\cite{Luqman2013} etc.

\subsection{Implicit graph embedding: Graph kernels}
\label{ssec:gm:ige}
\begin{definition}\emph{Implicit graph embedding} methods are based on \emph{graph kernels}. A graph kernel is a function $\kappa:\mathcal{G}\times\mathcal{G}\rightarrow\mathbb{R}$ for that a mapping $\Phi:\mathcal{G}\rightarrow\mathcal{H}$ to Hilbert space $\mathcal{H}$ exists, such that $\kappa(G_1,G_2)=\langle\Phi(G_1),\Phi(G_2)\rangle$ for all $G_1,G_2\in\mathcal{G}$.
\end{definition}

A graph kernel is a positive definite kernel on the set of graphs $\mathcal{G}$. Graph kernels can be defined on different substructures such as random walks~\cite{Gartner2003a}, shortest paths~\cite{Borgwardt2005}, cyclic patterns~\cite{Horvath2004}, graph edition~\cite{Dupe2009}, hierarchical bag of paths~\cite{Dupe2010} and backtrackless walks~\cite{Aziz2013} etc. The idea behind random walk kernel is to measure the similarity between graphs by counting the weighted common random walks between the operand graphs. This can be done by computing the \emph{tensor product graph} and using the property of the adjacency matrix of the product graph.

\section{Product graph}
\label{sec:gm:pg}
A \emph{product graph} is a graph generated from the \emph{graph product} operation on two graphs. In graph theory \emph{graph product} is a binary operation that takes two graphs $G_1(V_1,E_1)$ and $G_2(V_2,E_2)$ and produces a graph $G_X(V_X,E_X)$ with a vertex set $V_{X}$ as the Cartesian product $V_1\times V_2$ and an edge set $E_{X}$ depending on the criterion imposed during the graph product operation. In graph theory we talk about different product graphs depending on the definition of the edge set. In this section we will have a quick look on different type of product graphs, before that let us consider the following example which we will use to explain different definitions.

Let $G_1(V_1,E_1,L_{V_1},L_{E_1})$ and $G_2(V_2,E_2,L_{V_2},L_{E_2})$ be two graphs with sets of vertices $V_1=\lbrace1,2,3,4,5\rbrace$, $V_2=\lbrace1^\prime,2^\prime,3^\prime\rbrace$ and sets of edges $E_1=\lbrace (1,2)\mcomma(2,1)\mcomma(1,3)\mcomma(3,1)\mcomma(2,3)\mcomma(3,2)\mcomma(2,4)\mcomma(4,2)\mcomma(3,5)\mcomma(5,3) \mcomma(4,5)\mcomma(4,5)\rbrace$, $E_2=\lbrace(1^\prime,2^\prime)\mcomma(2^\prime,1^\prime)\mcomma(1^\prime,3^\prime)\mcomma(3^\prime,1^\prime) \mcomma(2^\prime,3^\prime)\mcomma(3^\prime,2^\prime)\rbrace$ (see Figure~\ref{fig:gm:cartesian_product_graph}).

%Here it is to be noted that the graph $G_2$ is a subgraph of $G_1$ where the correspondences among the nodes are $1 \leftrightarrow 1^\prime$, $2 \leftrightarrow 2^\prime$ and $3 \leftrightarrow 3^\prime$ and the correspondences among edges are $(1\mcomma 2) \leftrightarrow (1^\prime\mcomma 2^\prime)$, $(2\mcomma 3) \leftrightarrow (2^\prime\mcomma 3^\prime)$ and $(3,1) \leftrightarrow (3^\prime,1^\prime)$.

\begin{definition}
The simplest product graph is the \emph{Cartesian product graph}. It is defined as a product graph $G_X$ of two graphs $G_1(V_1,E_1)$ and $G_2(V_2,E_2)$ such that the vertex set $V_X$ of $G_X$ is the Cartesian product $V_1\times V_2$ \ie
\begin{align*}
V_X =\lbrace (u_1,u_2):u_1\in V_1, u_2\in V_2\rbrace
\end{align*}
and the edge set is defined as:
\begin{align*}
E_X =\lbrace ((u_1,u_2),(v_1,v_2)):u_1=v_1\text{ and }(u_2,v_2)\in E_2\text{ or }u_2=v_2\text{ and }(u_1,v_1)&\\ \in E_1,
u_1,v_1\in V_1, u_2,v_2\in V_2\rbrace&
\end{align*}
\end{definition}
An example of Cartesian product graph is shown in Figure~\ref{fig:gm:cartesian_product_graph}.

\begin{figure}[h!]
\begin{center}
\includegraphics[width=\textwidth]{cartesian_product_graph}
\caption{An example of Cartesian product graph.}
\label{fig:gm:cartesian_product_graph}
\end{center}
\end{figure}

\begin{definition}
The \emph{strong product graph} $G_X$ of two graphs $G_1(V_1,E_1)$ and $G_2(V_2,E_2)$ is a graph such that the vertex set $V_X$ of $G_X$ is the Cartesian product $V_1\times V_2$ \ie
\begin{align*}
V_X =\lbrace (u_1,u_2):u_1\in V_1, u_2\in V_2\rbrace
\end{align*}
and the edge set is defined as:
\begin{align*}
E_X =\lbrace ((u_1,u_2),(v_1,v_2)):u_1=v_1\text{ or }(u_1,v_1)\in E_1\text{ and }u_2=v_2\text{ or }&\\(u_2,v_2)\in E_2,
u_1,v_1\in V_1, u_2,v_2\in V_2\rbrace&
\end{align*}
\end{definition}
An example of strong product graph is shown in Figure~\ref{fig:gm:strong_product_graph}.

\begin{figure}
\begin{center}
\includegraphics[width=\textwidth]{strong_product_graph}
\caption{An example of a strong product graph.}
\label{fig:gm:strong_product_graph}
\end{center}
\end{figure}

\begin{definition}
The \emph{tensor product graph} $G_X$ of two graphs $G_1(V_1,E_1)$ and $G_2(V_2\mcomma E_2)$ is a graph such that the vertex set $V_X$ of $G_X$ is the Cartesian product $V_1\times V_2$ \ie
\begin{align*}
V_X =\lbrace (u_1,u_2):u_1\in V_1, u_2\in V_2\rbrace
\end{align*}
and the edge set is defined as:
\begin{align*}
E_X =\lbrace ((u_1,u_2),(v_1,v_2)):(u_1,v_1)\in E_1\text{ and }(u_2,v_2)\in E_2,u_1,v_1\in V_1,&\\
u_2,v_2\in V_2\rbrace&
\end{align*}
\end{definition}
An example of tensor product graph is shown in Figure~\ref{fig:gm:tensor_product_graph}.

\begin{figure}[h!]
\begin{center}
\includegraphics[width=\textwidth]{tensor_product_graph}
\caption{An example of a tensor product graph.}
\label{fig:gm:tensor_product_graph}
\end{center}
\end{figure}

Apart from the above instances, there are some other product graphs also, viz., \emph{lexicographical product graph}, \emph{modular product graph}, \emph{co-normal product graph} etc. In graph theory, mainly in artificial intelligence or machine learning the tensor product graph has got popularity for computing walk based graph kernel. Tensor product graph can also be called as \emph{direct product graph}, \emph{Kronecker product graph}, \emph{categorical product graph}, \emph{cardinal product graph} etc.

\section{Vectorization}
\label{sec:gm:vect}
Graph representation of graphical documents follows some pre-processing steps, vectorization is one of them. \emph{Vectorization} can be defined as approximating the binary images to a polygonal representation, which produces some points, lines, arcs or other entities. Particularly, in this thesis work we have used the Rosin-West algorithm~\cite{Rosin1989} for that purpose, which is implemented in the Qgar package\footnote{\url{http://www.qgar.org}}. This algorithm works without any parameter except the one for pruning the isolated components of black pixels. The algorithm produces a set of critical points and the information whether any two points are connected. Having this vectorized information one can construct the graph considering different entities such as points, lines as nodes or edges.

\subsection{Vectorization errors}
\label{ssec:gm:vect-errors}
The vectorized image often contains structural errors. Reasons for that can be inaccurate drawings, artefacts in the binarization or errors propagated from the polygonal approximation in vectorization. In this thesis we intend to solve this kind of errors in graph level. The structural errors can be broadly classified as follows:

\textit{Gaps} In drawings there can be small gaps between lines that ought to be connected. Reasons for that can be inaccurate drawings as well as loss of information in the binarization or disconnection in the approximation of the vectorization. The result can either be two disconnected points at the border of the gap or a point on one and a line on the other side of the gap. This kind of errors are often noticed in handwritten sketch as shown in \fig{fig:gm:vect-err1}.

\textit{Split critical points} On the other hand, an original critical point can be split into two or more points. This can happen, if lines in the drawing do not intersect exactly at one point. Another reason are artefacts from the skeletonization step. Nearby points that seem to be split points can be the result of fine details instead of vectorization errors. This kind of errors are shown in \fig{sfig:gm:table1a} and \fig{sfig:gm:table1b}.

\textit{Dispensable critical points} The vectorization can create critical points with two incident lines that divide a straight line into two or more nearly collinear lines. One reason for these points are small inaccuracies in the drawing that cause a local change in direction. Nevertheless, in some cases such structures reflect details of the symbol. Examples of these errors can be seen in \fig{fig:gm:vect-err1}.

\begin{figure}[!h]
\centering
\subfloat[]{\label{sfig:gm:table1}\includegraphics[width=0.29\textwidth]{table1}}
\hspace{1mm}
\subfloat[]{\label{sfig:gm:table1a}\includegraphics[width=0.29\textwidth]{table1-distortions1}}
\hspace{1mm}  
\subfloat[]{\label{sfig:gm:table1b}\includegraphics[width=0.36\textwidth,height=4.8cm]{table1-distortions2}}
\caption{Examples of structural distortions (spurious points, lines, discontinuous lines) for a graphical symbol: (a) A graphical symbol called \emph{table1}, (b) Vectorized image of the symbol in (a), this shows how even a undistorted symbol can become distorted after vectorization, (c) Vectorized image of the same symbol when appeared in a floorplan (note the spurious points and lines near the junction and corners).}
\label{fig:gm:vect-err2}
\end{figure}

\section{State-of-the-art in graph matching}
As this thesis mainly deals with subgraph matching algorithm, in this section we will exclusively review the subgraph matching algorithms. Interested readers can find a very robust and detailed review of various graph matching methods for pattern recognition problem in~\cite{Conte2004}. In pattern recognition, the research community has divided the graph matching methods into two broad categories: (1) exact and (2) inexact graph matching. The exact matching requires a strict correspondence among the two objects being matched or at least among their sub parts~\cite{Ullman1976,Cordella2004}. On the other hand the inexact graph matching methods allow some tolerance for matching and in this case a matching can occur where two graphs being matched can be structurally different to some extent~\cite{Pelillo1995,LladosPAMI2001}.

Most of the exact techniques rely on some kind of \emph{tree search with backtracking}. The basic idea is initially an empty matched list with pair of nodes is expanded with new pair of matched nodes. Each pair of nodes is chosen if they satisfy some kind of condition. For this kind of algorithm usually a set of heuristic is set which can eliminate some kind of absurd matching. The algorithm backtracks in case it reaches a partial condition where further expansion is not possible. The first algorithm in this category was proposed by Ullman~\cite{Ullman1976}. Cordella~\etal~proposed two algorithms viz. VF~\cite{Cordella1999} and VF2~\cite{Cordella2004} which also belong to this category. As it is mentioned before this kind of algorithm is not efficient when one has to find different solutions. Also determining the heuristic is also bit tricky, then also the algorithm can reach to a unfruitful solution.

Exact matching problem can also be formulated as \emph{constraint satisfaction problem}~\cite{Larrosa2002,Solnon2010}. This is a problem that has been studied deeply in discrete optimization framework and operational research. As most of the optimization based techniques, they aim to find local optima in approximated way and for that reason it is always possible for these algorithms to stuck in a solution near to the local optima. Moreover, optimization based techniques have high time complexity.

There are some subgraph matching algorithms aimed at reducing the matching time of one input graph against a large library of graphs. The method proposed by Messmer and Bunke in~\cite{Messmer2000} can be classified in this category. Here a recursive decomposition of each graph of the library is performed. This decompose the graphs into smaller subgraphs, until trivial, one node graphs are reached. The matching process, then, exploits the fact that some of the parts are common to several graphs in the library. This fact speeds up the matching procedure. Later a more impressive algorithm was proposed by the same author where they builds a decision tree from the graph library~\cite{Messmer1999}. The main problem that has been noticed of these algorithms is the space to store the built in libraries, which is exponential with respect to the number of nodes.

There are lot of arguments supporting the exact and inexact matching methods. Researchers often mention the characteristic of exact matching algorithms do not fit with realistic applications. This is because the description of object (or part of object) represented by graph is a vector resulted from some statistical analysis. So researchers proposed inexact graph matching.

\emph{Tree search with backtracking} can also be used for inexact subgraph matching problem. Usually this kind of algorithms are directed by the cost of partial matching obtained so far and a heuristic estimate of the matching cost for the remaining nodes. One of the first algorithms of this branch was proposed by Tsai and Hu~\cite{Tsai1979,Tsai1983}. In these papers they introduced the graph edit costs \ie~the costs for substituting, deleting and inserting nodes and edges. The main idea of such family of methods is to search for the minimum cost graph edit sequence that transform one graph to another.

\emph{Continuous optimization} methods have also been used for inexact graph matching. It consists in finding a matching matrix $X$, between a subset of the nodes of the first graph and a subset of the nodes of the second graph. The desired matching must optimize some function depending on the weights of the edges preserved by the match. The elements of $X$ are constrained to take the discrete values 0 and 1. One of the first algorithms in this branch was proposed by Almohamad and Duffuaa~\cite{Almohamad1993}. Then based on different optimization methods different algorithms were proposed, for example, graduated assignment graph matching~\cite{Gold1996}, maximal clique finding~\cite{Bomze2000,Pelillo1995}. None of the above algorithms addressed the subgraph matching problem. Very recently Le Bodic~\etal~proposed an integer linear programming based optimization method exclusively for subgraph isomorphism~\cite{LeBodic2012}. The main problem of this kind of optimization methods for graph matching is that they could stuck in a local optima. There are some algorithms that can take care of this situation but this technique is not feasible for all scenario. Also optimization methods are expensive and inefficient for bigger graph.

\begin{sidewaystable*}
\begin{center}
\caption{Summary table of different graph matching techniques.}
\begin{tabular}{m{1.6in}m{1.0in}m{1.0in}m{1.0in}m{1.2in}m{1.0in}}
\toprule
\hline
\textbf{Method} & \textbf{Heuristic} & \textbf{Risk of local optima} & \textbf{Size constraints} & 				   \textbf{Inexact matching} & \textbf{Time efficient}\\ \cr \hline
Ullman~\cite{Ullman1976} and Cordella~\cite{Cordella1999,Cordella2004}\hfill & $+$ & $+$ $+$ & $+$ & $-$ & $+$\\
Larrosa and Valiente~\cite{Larrosa2002} and Solnon~\cite{Solnon2010}\hfill & $-$ & $+$ & $+$ & $-$ & $+$\\
Messmer and Bunke in~\cite{Messmer1999,Messmer2000}\hfill & $-$ & $-$ & $+$ $+$ & $-$ & $+$\\
Tsai and Hu~\cite{Tsai1979,Tsai1983}\hfill & $+$ & $+$ $+$ & $+$ & $+$ & $+$\\
Almohamad and Duffuaa~\cite{Almohamad1993}\hfill & $-$ & $-$ & $+$ & $+$ & $+$\\
Bomze~\etal~\cite{Bomze2000} and Pelillo~\etal~\cite{Pelillo1995}\hfill & $-$ & $+$ $+$ & $+$ & $+$ & $-$\\
Le Bodic~\etal~\cite{LeBodic2012}\hfill & $-$ & $-$ $-$ & $+$ & $+$ & $-$\\
Shokoufandeh and Dickinson~\cite{Shokoufandeh2005}\hfill & $-$ & $-$ $-$ & $+$ & $+$ & $+$
\end{tabular}
\label{table:gm:sum-table}
\end{center}
\end{sidewaystable*}

\emph{Spectral methods} for graph matching are based on the observation that the eigenvalues and the eigenvectors of the adjacency matrix of a graph are invariant with respect to node permutations. Hence, if two graphs are isomorphic, their adjacency matrix will have the same eigenvalues and eigenvectors. The method which is slightly related to subgraph matching with spectral methods is presented by Shokoufandeh and Dickinson~\cite{Shokoufandeh2005}. The method is about indexing a hierarchical structure represented by a directed acyclic graph (DAG). They proposed to index each of the nodes of DAG in terms of the topological properties encoded by the spectral method under that node. To the best of knowledge we do not find many works in this category.
\section{Conclusions}
\label{sec:gm:concl}
In the literature we encounter different type of subgraph matching algorithms, the review is summarised in Table~\ref{table:gm:sum-table} based on some key qualities such as heuristic, risk of local optima, size constraints etc. This reveals that there are lack of methods that can deal with a big dataset of graphs. Nowadays, due to a huge development of imagery device the number of images in any of the field of computer vision is not limited. So developing algorithms that can deal with a substantial number of images with manageable time complexity is necessary. Also, different application fields evolve different problem from distortion, deformation point of view. Dealing those noisy data in the graph level is a challenging task. So this demands some work on having stable graph representation tolerating the distortions. Furthermore, graph can represent any kind of visual objects in terms of the relationship between different entities, which provides a robust representation paradigm. These are the main motivations for working on the graph representations and algorithms in this thesis.

Since this thesis work addresses symbol spotting in graphical documents from application point of view, in the next chapter, we are going to review the major works on symbol spotting. To do that we first divide the existing algorithms into five categories and review the available methods in each of them.